day 1--------------------------------------------------------------------
pattern questions 

*  *  *  *  *  
*  *  *  *  *  
*  *  *  *  *  
*  *  *  *  *  
*  *  *  *  *  

* * * * * 
*       * 
*       * 
* * * * *

* 
* * 
* * * 
* * * * 

day 2--------------------------------------------------------------------
//p5
* * * * 
* * *
* *
*
//p6
      * 
    * * 
  * * * 
* * * * 
//p7
1 
1 2 
1 2 3 
1 2 3 4 
1 2 3 4 5 

//p8
1 2 3 4 5 
1 2 3 4 
1 2 3 
1 2 
1 

//p9
1 
2 3 
4 5 6 
7 8 9 10 
11 12 13 14 15 

//p10
1
01
101
0101
10101

//p11
*             * 
* *         * * 
* * *     * * * 
* * * * * * * * 
* * * * * * * * 
* * *     * * * 
* *         * * 
*             * 

//p12
        * * * * *  
      * * * * *  
    * * * * *  
  * * * * *  
* * * * *  

//p13
        1   
      2   2   
    3   3   3   
  4   4   4   4   
5   5   5   5   5 

//p14
        1 
      2 1 2 
    3 2 1 2 3 
  4 3 2 1 2 3 4 
5 4 3 2 1 2 3 4 5

//p15
      *  
    * * *  
  * * * * *  
* * * * * * *  
* * * * * * * 
  * * * * * 
    * * * 
      * 


day 3--------------------------------------------------------------------
//f1
//Enter 3 numbers from the user & make a function to print their average.

//f2
//Write a function to print the sum of all odd numbers from 1 to n.

//f3
//Write a function that takes in the radius as input and returns the circumference of a circle.

//f4
//Write a program to enter the numbers till the user wants and at the end it should display the count of positive, negative and zeros entered. 

//f5
//Two numbers are entered by the user, x and n. Write a function to find the value of one number raised to the power of another i.e. xn.


day 4--------------------------------------------------------------------
//f6
// gdc using recursion

//f7
//febonacci series 

//day 5
basics of array 
//A1
 
 //A2 enter size and elements in array
 //A3 Find a element

 //day 6
 2d array
//

//day 7
Strign builder operation like 
CharAt
setChatAt
insert
delete
 
also operator and binary numbers(no programs)

//day 8
left shift
A=0101
A<<1
A=1010

Right shift
A=0101
A>>1
0010

//bitw get bit
//bitw2 setbit
//bitw3 clearbit
//bitw4 update for 1 we use setbit(&) and for 0 we use clear(or)



//on day 9 we start a very essential topic i.e sorting 
//Sort1
Bubble Sort
we initally go through what bubble swap is 
Bubble sort is a sorting algorithm that compares adjacent elements and swaps them if they are not in the intended order.
The process of swapping two adjacent elements is referred to as a "bubble swap." This swapping continues until the entire list is sorted.
prefferd when data is partially sorted or data is relatively smaller.

//Sort2
Selection Sort
Selection sort is a simple sorting algorithm that works by repeatedly finding the minimum element from the unsorted portion of the array and swapping it with the first unsorted element.
This process continues until the entire array is sorted.
It is Best for:
-Small array
-Systems where writes/swaps are costly
-When you need constant memory and don’t care about speed
Not good for:
-Large datasets
-Cases needing fast, stable sorting

//Sort3
Insertion Sort
Insertion sort is a simple sorting algorithm that builds the final sorted array one item at a time by comparisons
Insertion sort is preferred in scenarios where the data is nearly sorted or when the problem size is small due to its low overhead and adaptability.


| Feature          | Selection Sort          | Insertion Sort     | Bubble Sort                |
| ---------------- | ----------------------- | ------------------ | -------------------------- |
| Time (avg/worst) | O(n²)                   | O(n²) (O(n) best)  | O(n²)                      |
| Swaps            | Fewest (≤ n)            | Moderate           | Most (many swaps)          |
| Stable?          | No                      | Yes                | Yes                        |
| Best Use         | Few writes, tiny arrays | Nearly sorted data | Teaching, very small cases |

//d10
here we begin with reccursion.
Recursion is used for solving problems that can be broken down into smaller, similar subproblems.
It is particularly useful for tasks such as calculating factorials, generating Fibonacci sequences, and traversing tree structures.
Recursion provides a clean and simple way to write code for problems that are inherently recursive.
However, it is important to note that recursion can be memory-intensive and may lead to stack overflow errors if not implemented carefully.

